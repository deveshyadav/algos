1Ô∏è‚É£ Sliding Window  
This pattern is used when a problem involves finding a subarray or substring that meets a condition. The window expands or shrinks dynamically, making it highly efficient for problems that involve continuous sequences in arrays or strings.

‚úÖ Most Important Questions (6 Total):

- **Longest Substring Without Repeating Characters (üî• LeetCode 3)**  
  Find the longest substring with all unique characters.  
  *Also fits in: Two Pointers*

- **Longest Repeating Character Replacement (LeetCode 424)**  
  Find the longest substring that can be converted into a repeating character string by replacing at most k characters.

- **Minimum Window Substring (üî• LeetCode 76)**  
  Find the smallest substring that contains all characters of another string.  
  *Also fits in: Two Pointers*

- **Maximum Sum Subarray (Kadane‚Äôs Algorithm) (LeetCode 53)**  
  Find the subarray with the largest sum in an array.  
  *Also fits in: Dynamic Programming*

- **Find All Anagrams in a String (LeetCode 438)**  
  Find all substrings in s that are anagrams of p.

- **Smallest Subarray with Sum ‚â• K (LeetCode 209)**  
  Find the shortest subarray whose sum is at least K.


2Ô∏è‚É£ Two Pointers  
This pattern is useful for problems where we need to search, compare, or merge elements efficiently. The two pointers usually move towards each other or in the same direction based on the problem.

‚úÖ Most Important Questions (7 Total):

- **Two Sum (Sorted Array) (üî• LeetCode 167)**  
  Given a sorted array, find two numbers that sum to a target.  
  *Also fits in: Binary Search Variations*

- **Three Sum (üî• LeetCode 15)**  
  Find all unique triplets in an array that sum to zero.

- **Container With Most Water (üî• LeetCode 11)**  
  Find two vertical lines that form a container with the most water.

- **Valid Palindrome (LeetCode 125)**  
  Check if a given string is a palindrome, considering only alphanumeric characters.

- **Remove Duplicates from Sorted Array (LeetCode 26)**  
  Remove duplicates from a sorted array in-place.

- **Minimum Window Substring (üî• LeetCode 76)**  
  Find the smallest substring in s that contains all characters of t.  
  *Also fits in: Sliding Window*

- **Sort Colors (Dutch National Flag Algorithm) (üî• LeetCode 75)**  
  Sort an array containing only 0s, 1s, and 2s in-place.  
  *Also fits in: Greedy Algorithm*


3Ô∏è‚É£ Fast & Slow Pointers  
This pattern is mainly used in cycle detection, finding middle elements, and linked list problems.

‚úÖ Most Important Questions (5 Total):

- **Linked List Cycle Detection (üî• LeetCode 141)**  
  Detect if a linked list has a cycle using Floyd‚Äôs Tortoise and Hare algorithm.

- **Find the Middle of a Linked List (LeetCode 876)**  
  Find the middle node of a linked list efficiently.

- **Find Duplicate Number in an Array (LeetCode 287)**  
  Given an array of n+1 numbers in range [1, n], find the duplicate without modifying the array.

- **Reorder List (LeetCode 143)**  
  Rearrange a linked list to follow the pattern: L0 ‚Üí Ln ‚Üí L1 ‚Üí Ln-1 ‚Üí L2 ‚Üí Ln-2 ‚Üí ‚Ä¶.

- **Detect Start of Cycle in a Linked List (LeetCode 142)**  
  After detecting a cycle, find the starting node of the loop.


4Ô∏è‚É£ Backtracking  
This pattern is used for problems involving exploring all possibilities recursively (e.g., permutations, subsets, and constraint-based searches).

‚úÖ Most Important Questions (8 Total):

- **Word Search (LeetCode 79)**  
  Given a 2D board and a word, check if the word exists by moving adjacent letters.

- **Generate Parentheses (LeetCode 22)**  
  Generate all valid parentheses combinations for a given number n.

- **N-Queens (üî• LeetCode 51)**  
  Place N queens on an N √ó N chessboard such that no two queens attack each other.

- **Sudoku Solver (LeetCode 37)**  
  Fill a partially completed Sudoku board using backtracking.

- **Subsets (LeetCode 78)**  
  Generate all subsets of a given array (Power Set).

- **Permutations (LeetCode 46)**  
  Generate all unique permutations of a given array.

- **Palindrome Partitioning (LeetCode 131)**  
  Partition a string into palindromic substrings.

- **Restore IP Addresses (LeetCode 93)**  
  Generate all valid IP addresses from a given string.


5Ô∏è‚É£ Merge Intervals  
Used when working with overlapping intervals.

‚úÖ Most Important Questions (6 Total):

- **Merge Intervals (üî• LeetCode 56)**  
  Given a set of intervals, merge overlapping ones.

- **Insert Interval (LeetCode 57)**  
  Insert a new interval into an existing list while merging if necessary.

- **Meeting Rooms (LeetCode 252)**  
  Determine if a person can attend all meetings (no overlaps).

- **Meeting Rooms II (LeetCode 253)**  
  Find the minimum number of meeting rooms required.

- **Minimum Number of Arrows to Burst Balloons (LeetCode 452)**  
  Find the minimum number of arrows to burst all balloons represented as intervals.

- **Interval List Intersections (LeetCode 986)**  
  Given two lists of sorted intervals, find their intersection intervals.


6Ô∏è‚É£ Binary Search Variations  
Used for efficient searching in sorted or semi-sorted data.

‚úÖ Most Important Questions (5 Total):

- **Binary Search (LeetCode 704)**  
  Classic binary search to find a target in a sorted array.

- **Search in Rotated Sorted Array (üî• LeetCode 33)**  
  Search for a target in a rotated sorted array in O(log n).

- **Find Peak Element (LeetCode 162)**  
  Find a peak element in an unsorted array.

- **Median of Two Sorted Arrays (üî• LeetCode 4)**  
  Find the median of two sorted arrays in O(log(min(m, n))) time.

- **Find Kth Smallest Element in a Sorted Matrix (LeetCode 378)**  
  Find the k-th smallest element in a row-wise & column-wise sorted matrix.


7Ô∏è‚É£ Top-K Elements (Heap-based)  
Used when dealing with frequent min/max tracking, priority-based problems, and streaming data.

‚úÖ Most Important Questions (6 Total):

- **Kth Largest Element in an Array (üî• LeetCode 215)**  
  Find the k-th largest element in an unsorted array using a min-heap.

- **Top K Frequent Elements (LeetCode 347)**  
  Find the k most frequent numbers in an array.

- **K Closest Points to Origin (LeetCode 973)**  
  Find the k closest points to the origin (0,0).

- **Find Median from Data Stream (LeetCode 295)**  
  Implement a class that dynamically maintains and returns the median of a data stream.

- **Sliding Window Maximum (LeetCode 239)**  
  Find the maximum value in every window of size k.

- **Task Scheduler (LeetCode 621)**  
  Given tasks with cooldown times, find the minimum time needed to schedule all tasks.


8Ô∏è‚É£ Dynamic Programming (DP)  
Used for problems involving overlapping subproblems and optimal substructure.

‚úÖ Most Important Questions (9 Total):

- **Climbing Stairs (LeetCode 70)**  
  Count the number of distinct ways to climb n stairs.

- **House Robber (üî• LeetCode 198)**  
  Find the maximum sum from non-adjacent houses.

- **House Robber II (LeetCode 213)**  
  Variant of House Robber, but houses are arranged in a circle.

- **Longest Palindromic Substring (üî• LeetCode 5)**  
  Find the longest palindromic substring using dynamic programming.

- **Edit Distance (Levenshtein Distance) (üî• LeetCode 72)**  
  Find the minimum operations to convert one string to another.

- **Longest Common Subsequence (LeetCode 1143)**  
  Find the length of the longest subsequence common to two strings.

- **Coin Change (LeetCode 322)**  
  Find the minimum number of coins needed to make a given amount.

- **Decode Ways (LeetCode 91)**  
  Count the number of ways to decode a numeric string.

- **Word Break (LeetCode 139)**  
  Check if a given string can be segmented into words from a dictionary.


9Ô∏è‚É£ Graph Traversal (BFS / DFS)  
Used for traversing graphs and trees efficiently.

‚úÖ Most Important Questions (7 Total):

- **Number of Islands (üî• LeetCode 200)**  
  Count the number of islands in a grid using BFS or DFS.

- **Clone Graph (LeetCode 133)**  
  Clone an undirected graph using BFS or DFS.

- **Pacific Atlantic Water Flow (LeetCode 417)**  
  Find grid cells that can reach both the Pacific and Atlantic oceans.

- **Word Ladder (LeetCode 127)**  
  Find the shortest transformation sequence from beginWord to endWord.

- **Course Schedule (Cycle Detection in Directed Graph) (LeetCode 207)**  
  Check if a course schedule can be completed given prerequisites.

- **Rotting Oranges (LeetCode 994)**  
  Find the minimum time needed for all oranges to rot using BFS.

- **Flood Fill Algorithm (LeetCode 733)**  
  Implement the flood-fill algorithm used in image processing.


üîü Greedy Algorithm  
Used when local optimal choices lead to a globally optimal solution.

‚úÖ Most Important Questions (6 Total):

- **Activity Selection Problem (Classic Greedy)**  
  Find the maximum number of activities that can be performed.

- **Huffman Encoding**  
  Implement Huffman encoding for lossless data compression.

- **Jump Game (LeetCode 55)**  
  Determine if you can reach the last index from the first index.

- **Gas Station (LeetCode 134)**  
  Determine if you can travel around a circular gas station route.

- **Minimum Number of Platforms (Train Schedule Problem)**  
  Find the minimum number of platforms required for railway stations.

- **Fractional Knapsack Problem (Greedy Optimization)**  
  Choose items for a knapsack to maximize total value while staying within weight constraints.


1Ô∏è‚É£1Ô∏è‚É£ Bitwise Tricks  
Used for efficient calculations using bit manipulation.

‚úÖ Most Important Questions (4 Total):

- **Single Number (XOR Trick) (üî• LeetCode 136)**  
  Find the number that appears only once in an array where every other number appears twice.

- **Counting Set Bits (LeetCode 191)**  
  Count the number of 1s in the binary representation of a number.

- **Power of Two (LeetCode 231)**  
  Check if a number is a power of two using bitwise operations.

- **Reverse Bits (LeetCode 190)**  
  Reverse the bits of a given 32-bit unsigned integer.


1Ô∏è‚É£2Ô∏è‚É£ Recursion & Divide and Conquer  
Used for breaking problems down into subproblems and solving recursively.

‚úÖ Most Important Questions (7 Total):

- **Merge Sort**  
  Implement merge sort using divide and conquer.

- **QuickSort**  
  Implement quicksort using recursion and partitioning.

- **Find Kth Largest Element in an Array (Using QuickSelect) (üî• LeetCode 215)**  
  Find the k-th largest element using QuickSelect (an optimization of quicksort).

- **Closest Pair of Points (Divide & Conquer)**  
  Find the closest pair of points in a 2D plane.

- **Pow(x, n) (Exponentiation by Squaring) (LeetCode 50)**  
  Implement x^n in logarithmic time.

- **Median of Two Sorted Arrays (üî• LeetCode 4)**  
  Find the median of two sorted arrays in O(log(min(m, n))).  
  *Also fits in: Binary Search Variations*

- **Largest Rectangle in Histogram (LeetCode 84)**  
  Find the largest rectangle that can be formed in a histogram.


üöÄ Algorithm-Based Patterns & Must-Solve Questions  
These are additional algorithmic techniques that don‚Äôt fit into problem-solving patterns but are core algorithms you must know.

1Ô∏è‚É£ Sorting Algorithms  
Sorting is used as a helper technique in many problems (e.g., Two Pointers, Greedy, Divide & Conquer).

‚úÖ Most Important Questions (6 Total):

- **Merge Sort (Divide & Conquer)**  
  Implement merge sort for sorting an array in O(n log n).

- **QuickSort (Divide & Conquer)**  
  Implement quicksort and analyze its best/average/worst-case time complexity.

- **Sort Colors (Dutch National Flag Algorithm) (üî• LeetCode 75)**  
  Sort an array containing only 0s, 1s, and 2s in-place.  
  *Also fits in: Two Pointers*

- **Largest Number (Custom Comparator Sorting) (LeetCode 179)**  
  Arrange a list of numbers to form the largest possible number.

- **H-Index (Sorting-Based Approach) (LeetCode 274)**  
  Find the H-index of a researcher given their citations.

- **Merge K Sorted Lists (Heap + Sorting) (LeetCode 23)**  
  Merge k sorted linked lists into one sorted list.  
  *Also fits in: Heap-Based Problems*

2Ô∏è‚É£ Searching Algorithms  
Searching is used for locating elements efficiently in various data structures.

‚úÖ Most Important Questions (5 Total):

- **Binary Search (Classic Implementation) (LeetCode 704)**  
  Implement binary search on a sorted array.  
  *Also fits in: Binary Search Variations*

- **Search in Rotated Sorted Array (üî• LeetCode 33)**  
  Find a target in a rotated sorted array in O(log n).

- **Find First and Last Position of an Element (LeetCode 34)**  
  Given a sorted array, find the first and last occurrence of a target value.

- **Median of Two Sorted Arrays (üî• LeetCode 4)**  
  Find the median of two sorted arrays in O(log(min(m, n))).  
  *Also fits in: Divide and Conquer*

- **Find Peak Element (Binary Search Approach) (LeetCode 162)**  
  Find a peak element in an array where nums[i] ‚â† nums[i+1].

3Ô∏è‚É£ Graph Algorithms  
Graph algorithms go beyond BFS/DFS and are used for shortest paths, spanning trees, and connectivity problems.

‚úÖ Most Important Questions (7 Total):

- **Dijkstra‚Äôs Algorithm (Shortest Path in Graph)**  
  Find the shortest path from a source to all other vertices in a weighted graph.

- **Bellman-Ford Algorithm (Negative Weight Edges)**  
  Find shortest paths while handling negative weights.

- **Kruskal‚Äôs Algorithm (Minimum Spanning Tree)**  
  Find the minimum spanning tree using a greedy approach.

- **Prim‚Äôs Algorithm (Minimum Spanning Tree)**  
  Another method for finding the minimum spanning tree.

- **Topological Sorting (Kahn‚Äôs Algorithm)**  
  Find a valid order of tasks (nodes) in a DAG (Directed Acyclic Graph).

- **Find Bridges in Graph (Tarjan‚Äôs Algorithm)**  
  Find all bridges (critical edges) in a graph.

- **Find Strongly Connected Components (Kosaraju‚Äôs Algorithm)**  
  Identify SCCs in a directed graph.

4Ô∏è‚É£ String Searching Algorithms  
Used when working with pattern matching and substring search.

‚úÖ Most Important Questions (5 Total):

- **KMP Algorithm (Knuth-Morris-Pratt)**  
  Implement KMP for efficient substring search (O(n)).

- **Rabin-Karp Algorithm (Rolling Hash)**  
  Find a substring using a rolling hash.

- **Z-Algorithm (Efficient Pattern Matching)**  
  Find all occurrences of a pattern in a string in O(n+m).

- **Find All Anagrams in a String (LeetCode 438)**  
  Find all substrings in s that are anagrams of p.  
  *Also fits in: Sliding Window*

- **Implement strStr() (Substring Search) (LeetCode 28)**  
  Implement an efficient version of indexOf().

5Ô∏è‚É£ Mathematical & Combinatorial Algorithms  
These algorithms help with number-based calculations and combinatorial problems.

‚úÖ Most Important Questions (6 Total):

- **Euclidean Algorithm (Greatest Common Divisor - GCD)**  
  Find the GCD of two numbers using the Euclidean method.

- **Sieve of Eratosthenes (Find All Primes ‚â§ n)**  
  Find all prime numbers up to n efficiently.

- **Modular Exponentiation (Fast Powering Algorithm)**  
  Compute (x^y) % p efficiently.

- **Chinese Remainder Theorem (CRT)**  
  Solve systems of congruences (important in cryptography).

- **Floyd‚Äôs Tortoise and Hare (Cycle Detection in Numbers)**  
  Detect cycles in numbers (e.g., Happy Number problem).  
  *Also fits in: Fast & Slow Pointers*

- **N Choose K (Combinations Formula in DP)**  
  Compute nCk efficiently for combinatorial problems.

---
